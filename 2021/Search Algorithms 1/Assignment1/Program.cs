using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;

namespace Assignment1 {
    class Program {
        static void Main(string[] args) {
            // Set up a simple text menu for choosing puzzle and settings
            Console.WriteLine("This program will solve n-puzzle and n-queens problems.");

            // Specify puzzle to solve
            Console.WriteLine("Which problem do you wish to solve?");
            Console.WriteLine("1 - n-puzzle");
            Console.WriteLine("2 - n-queens");

            int puzzleType = 0;

            // Input validation for both type and range of values
            while (!int.TryParse(Console.ReadLine(), out puzzleType) || puzzleType < 1 || puzzleType > 2) {
                Console.WriteLine("Please input a valid option, integer only.");
            }

            // Specify size of n
            Console.WriteLine("Please input the value of n.");

            int n = 0;

            while (!int.TryParse(Console.ReadLine(), out n) || n <= 0) {
                Console.WriteLine("Please input a positive integer for n.");
            }

            // Specify search type/algorithm
            Console.WriteLine("Which algorithm would you like to search with?");
            Console.WriteLine("Type any of the following strings in quotes to make your selection.");
            Console.WriteLine("1 - depth-first");
            Console.WriteLine("2 - breadth-first");
            Console.WriteLine("3 - iterative deepening");
            Console.WriteLine("4 - bi-directional");

            int searchInt = 0;

            while (!int.TryParse(Console.ReadLine(), out searchInt) || searchInt < 1 || searchInt > 4) {
                Console.WriteLine("Please select one of the valid options, remember to only input the integer.");
            }

            // Quick exception for bi-directional search as it needs goal states which are not implemented past n = 8
            // Also handles n < 4 which are either trivial or impossible
            if ((n < 4 || n > 8) && searchInt == 4 && puzzleType == 2) {
                Console.WriteLine("Please note that due to bi-directional search requiring a goal state, we did not implement the goals for n > 8 queens problem.");
                Console.WriteLine("Any n < 4 is also invalid for the queens problem as well.");
                Console.WriteLine("Please restart the program and select your parameters again.");
                Console.WriteLine("Press any key to continue...");
                Console.ReadKey();
                Environment.Exit(0);
            }

            // Convert searchInt into the proper string
            string searchType = "";

            switch(searchInt) {
                case 1:
                    searchType = "df";
                    break;

                case 2:
                    searchType = "bf";
                    break;

                case 3:
                    searchType = "id";
                    break;

                case 4:
                    searchType = "bd";
                    break;
            }

            int initialMoves = 0;

            if (puzzleType == 1) {
                // Since the program generates an initial state by "scrambling" a solved puzzle, the user specifies how many times to move from the initial state
                Console.WriteLine("Lastly, the initial state is generated by moving the blank spot x times to get the puzzle the algorithm will solve.");
                Console.WriteLine("What would you like that number, x, to be?");

                while (!int.TryParse(Console.ReadLine(), out initialMoves) || initialMoves <= 0) {
                    Console.WriteLine("Please input a positive integer for x.");
                }
            }
            

            // Generate the initial state
            Console.WriteLine("Generating an initial state...");
            PuzzleState initial;
            LinkedList<PuzzleState> solution = null;

            // Create a stopwatch to keep track of time
            Stopwatch watch = new Stopwatch();

            if (puzzleType == 1) {
                initial = Npuzzle.Generate(n, initialMoves);

                Console.WriteLine("Solving for generated n-puzzle...");

                watch.Start();
                solution = Npuzzle.SolvePuzzle(n, initial, searchType);
                watch.Stop();
                
            } else {
                initial = Nqueens.Generate(n);

                Console.WriteLine("Solving for generated n-queens puzzle...");

                watch.Start();
                solution = Nqueens.SolvePuzzle(n, initial, searchType);
                watch.Stop();
            }

            if ( solution == null) {
                Console.WriteLine("Either puzzle is invalid, or solution could not be found.");

                Console.WriteLine("Press any key to continue...");
                Console.ReadKey();

                Environment.Exit(0);
            }

            Console.WriteLine("Solution found with {0} steps in {1} seconds!", solution.Length, watch.ElapsedMilliseconds / 1000.0);

            Console.WriteLine("Would you like a text file of the steps? (y/n)");
            char response;

            while (!char.TryParse(Console.ReadLine(), out response) || char.ToLower(response) != 'y' && char.ToLower(response) != 'n') {
                Console.WriteLine("Please input a valid option, only a single char y or n.");
            }

            if (char.ToLower(response) == 'y') {
                // Build the filename
                string filename;
                if (puzzleType == 1) filename = "npuzzle";
                else filename = "nqueens";
                filename += "_";
                filename += n;
                filename += "_solution.txt";

                try {
                    // Find the max number of digits using n, for formatting purposes
                    int digits = (int)Math.Floor(Math.Log10(n + 1) + 1);
                    string format = "{0:d" + digits + "} ";

                    StreamWriter sw = new StreamWriter(filename);
                    LinkedList<PuzzleState>.Node node = solution.First;

                    for (int i = 0; i < solution.Length; i++) {
                        for (int y = 0; y < node.data.Width; y++) {
                            for (int x = 0; x < node.data.Width; x++) {
                                sw.Write(format, node.data[x, y]);
                            }
                            sw.WriteLine();
                        }
                        sw.WriteLine();
                        node = node.next;
                    }

                    sw.Close();

                } catch (IOException e) {
                    Console.WriteLine("Something went wrong when writing to the file:");
                    Console.WriteLine(e);
                }

                Console.WriteLine("File written successfully.");
            }

            Console.WriteLine("Press any key to continue...");
            Console.ReadKey();
        }
    }

    class Npuzzle {
        int puzzleSize;
        PuzzleState goal;

        public static LinkedList<PuzzleState> SolvePuzzle(int n, PuzzleState state, string searchType) {
            double size = Math.Sqrt(n + 1);
            if (size % 1 != 0) {
                return null;
            }

            Npuzzle puzzle = new Npuzzle(n);
            GraphSearch<PuzzleState> solver = new GraphSearch<PuzzleState>();
            return solver.graphSearch(state, puzzle.CheckGoal, puzzle.ComputeSuccessors, searchType, puzzle.goal);
        }

        public static PuzzleState Generate(int n, int steps) {
            double size = Math.Sqrt(n + 1);
            if (size % 1 != 0) {
                return null;
            }

            int[] boardVals = new int[n + 1];

            for (int i = 0; i <= n; i++) {
                boardVals[i] = i;
            }

            // After generating the possible values, we start with a solved puzzle and move the empty space a set number of times (steps)
            // This helps us find a solution within a decent amount of time
            PuzzleState board = new PuzzleState(boardVals, (int)size);
            Random random = new Random();
            int[] zero = new int[] { 0, 0 };

            // For loop for making the input amount of steps from the solution
            for (int i = 0; i < steps; i++) {
                int move = -1;

                // Do while to move in one of 4 random directions
                // If that direction is invalid (out of bounds) then set move to -1 and regenerate number
                do {
                    move = random.Next(4);

                    switch(move) {
                        // Up
                        case 0:
                            if (zero[1] - 1 >= 0) {
                                board.Swap(zero[0], zero[1], zero[0], zero[1] - 1);
                                zero[1]--;
                            } else {
                                move = -1;
                            }
                            break;
                        // Left
                        case 1:
                            if (zero[0] - 1 >= 0) {
                                board.Swap(zero[0], zero[1], zero[0] - 1, zero[1]);
                                zero[0]--;
                            } else {
                                move = -1;
                            }
                            break;
                        // Down
                        case 2:
                            if (zero[1] + 1 < size) {
                                board.Swap(zero[0], zero[1], zero[0], zero[1] + 1);
                                zero[1]++;
                            } else {
                                move = -1;
                            }
                            break;
                        
                        // Right
                        case 3:
                            if (zero[0] + 1 < size) {
                                board.Swap(zero[0], zero[1], zero[0] + 1, zero[1]);
                                zero[0]++;
                            } else {
                                move = -1;
                            }
                            break;
                    }
                } while (move == -1);
            }

            return board;
        }

        // Constructor defines goal for the n-puzzle problem
        // In this implementation, we use the variable n as the dimension of the square, like its length for instance
        public Npuzzle(int n) {
            puzzleSize = (int)Math.Sqrt(n + 1);
            int[] vals = new int[n + 1];

            for (int i = 0; i <= n; i++) {
                vals[i] = i;
            }

            goal = new PuzzleState(vals, puzzleSize);
        }

        // Function to check if a state is equal to the goal
        public bool CheckGoal(PuzzleState state) {
            state.Print(); // Prints the current puzzle state that is being compared, used for debugging
            return state.Equals(goal);
        }

        public LinkedList<PuzzleState> ComputeSuccessors(PuzzleState state) {
            int[] zero = FindZero(state);
            LinkedList<PuzzleState> ret = new LinkedList<PuzzleState>();
            PuzzleState alteredState;

            // Move each of the four directions if possible, and then add the new state to the list
            // Also before adding the state, make sure that it has not already been created before
            // Start with up
            if (zero[1] - 1 >= 0) {
                alteredState = new PuzzleState(state);
                alteredState.Swap(zero[0], zero[1], zero[0], zero[1] - 1);
                ret.Append(alteredState);
            }

            // Finally, left
            if (zero[0] - 1 >= 0) {
                alteredState = new PuzzleState(state);
                alteredState.Swap(zero[0], zero[1], zero[0] - 1, zero[1]);
                ret.Append(alteredState);
            }

            // Then down
            if (zero[1] + 1 < puzzleSize) {
                alteredState = new PuzzleState(state);
                alteredState.Swap(zero[0], zero[1], zero[0], zero[1] + 1);
                ret.Append(alteredState);
            }

            // Next is right
            if (zero[0] + 1 < puzzleSize) {
                alteredState = new PuzzleState(state);
                alteredState.Swap(zero[0], zero[1], zero[0] + 1, zero[1]);
                ret.Append(alteredState);
            }

            // Return the completed list
            return ret;
        }

        private static int[] FindZero(PuzzleState state) {
            int[] pos = new int[2];

            for (pos[1] = 0; pos[1] < state.Width; pos[1]++) {
                for (pos[0] = 0; pos[0] < state.Width; pos[0]++) {
                    if (state[pos[0], pos[1]] == 0) {
                        return pos;
                    }
                }
            }

            // This should never happen, but C# needs to be happy
            return new int[2] { -1, -1 };
        }
    }

    class Nqueens {
        int n;
        PuzzleState goal;

        public static LinkedList<PuzzleState> SolvePuzzle(int n, PuzzleState state, string searchType) {
            Nqueens queensPuzzle = new Nqueens(n);
            GraphSearch<PuzzleState> solver = new GraphSearch<PuzzleState>();
            return solver.graphSearch(state, queensPuzzle.CheckGoal, queensPuzzle.ComputeSuccessors, searchType, queensPuzzle.goal);
        }

        public static PuzzleState Generate(int n) {
            int[] board = new int[n * n];

            // Populate the initial state with 1 representing a queen
            // 0 represents an empty space
            // Initial state will always be all queens starting on the top row
            for (int i = 0; i < n*n; i++) {
                if (i < n) board[i] = 1;
                else board[i] = 0;
            }

            return new PuzzleState(board, n);
        }

        // In order to function with bi-directional search we need some goal states
        // Since there are several goal states per given n, we will simply store a few
        // for 4 <= n <= 8
        public void SetGoal() {
            int[] board = null;

            switch (n) {
                case 4:
                    board = new int[] { 0, 0, 1, 0,
                                        1, 0, 0, 0,
                                        0, 0, 0, 1,
                                        0, 1, 0, 0 };
                    break;

                case 5:
                    board = new int[] { 0, 0, 0, 1, 0,
                                        0, 1, 0, 0, 0,
                                        0, 0, 0, 0, 1,
                                        0, 0, 1, 0, 0,
                                        1, 0, 0, 0, 0 };
                    break;

                case 6:
                    board = new int[] { 0, 0, 0, 1, 0, 0,
                                        1, 0, 0, 0, 0, 0,
                                        0, 0, 0, 0, 1, 0,
                                        0, 1, 0, 0, 0, 0,
                                        0, 0, 0, 0, 0, 1,
                                        0, 0, 1, 0, 0, 0 };
                    break;

                case 7:
                    board = new int[] { 0, 1, 0, 0, 0, 0, 0,
                                        0, 0, 0, 1, 0, 0, 0,
                                        1, 0, 0, 0, 0, 0, 0,
                                        0, 0, 0, 0, 0, 0, 1,
                                        0, 0, 0, 0, 1, 0, 0,
                                        0, 0, 1, 0, 0, 0, 0,
                                        0, 0, 0, 0, 0, 1, 0 };
                    break;

                case 8:
                    board = new int[] { 0, 0, 1, 0, 0, 0, 0, 0,
                                        0, 0, 0, 0, 0, 1, 0, 0,
                                        0, 0, 0, 0, 0, 0, 0, 1,
                                        1, 0, 0, 0, 0, 0, 0, 0,
                                        0, 0, 0, 1, 0, 0, 0, 0,
                                        0, 0, 0, 0, 0, 0, 1, 0,
                                        0, 0, 0, 0, 1, 0, 0, 0,
                                        0, 1, 0, 0, 0, 0, 0, 0 };
                    break;
            }

            // Set goal to null if n is not within this range, otherwise return the goal state
            goal = board == null ? null : new PuzzleState(board, n);
        }

        public Nqueens(int n) {
            this.n = n;
            SetGoal();
        }

        // Function used for ensuring no queens are attacking each other
        // Note that this does not check the columns since we are not allowing the queens
        // to change columns when moving
        public bool CheckGoal(PuzzleState state) {
            // First we will check all rows for more than 1 queen
            for (int y = 0; y < n; y++) {
                int queenCount = 0;

                for (int x = 0; x < n; x++) {
                    // Since queens are 1 and empty spaces are 0, this will naturally give us the number of queens for this row
                    queenCount += state[x, y];
                }

                // If more than one queen has been found in this row, then the puzzle is not solved
                if (queenCount > 1) return false;
            }

            // Now that the rows are complete, and no need to check columns...
            // Check diagonals
            for (int i = 0; i < n - 1; i++) {
                int queenCountXPos = 0;
                int queenCountYPos = 0;
                int queenCountXNeg = 0;
                int queenCountYNeg = 0;

                for (int j = 0; i + j < n; j++) {
                    queenCountXPos += state[i + j, j];
                    queenCountYPos += state[j, i + j];
                    queenCountXNeg += state[(n - 1) - (i + j), j];
                    queenCountYNeg += state[(n - 1) - j, i + j];
                }

                if (queenCountXPos > 1 || queenCountYPos > 1 || queenCountXNeg > 1 || queenCountYNeg > 1) return false;
            }

            // If both are checked and no queens are on same row/diagonal, then we have the solution
            return true;
        }

        public LinkedList<PuzzleState> ComputeSuccessors(PuzzleState state) {
            LinkedList<PuzzleState> ret = new LinkedList<PuzzleState>();
            PuzzleState alteredState;
            
            // Search all columns for each queen and move it to all possible spaces
            // All resulting boards will be added as children
            for (int x = 0; x < n; x++) {
                // First, find the queen "q" by iterating through the column
                int q;
                for (q = 0; q < n; q++) {
                    if (state[x, q] == 1) break;
                }

                for (int y = 0; y < n; y++) {
                    // If current coordinate is where the queen is, skip
                    if (y == q) continue;

                    alteredState = new PuzzleState(state);
                    alteredState.Swap(x, q, x, y);
                    ret.Append(alteredState);
                }
            }

            return ret;
        }
    }

    // Graph Search class is for the sake of the previousStates list, as it is important for comparison to avoid dupes or find solutions in the case of bi-directional search
    class GraphSearch<T> {
        LinkedList<T> previousStates = new LinkedList<T>();

        public LinkedList<T> graphSearch(T data, Func<T, bool> checkGoal, Func<T, LinkedList<T>> computeSuccessors, string searchType, T bdEndState=default(T)) {
            Tree<T> root = new Tree<T>(data);

            // Breadth-first search
            if (searchType == "bf") {
                Tree<T> solution = BreadthSearch(root, checkGoal, computeSuccessors);

                // If the solution was found then we return the proper steps for the solution
                if (solution != null) return SolutionSteps(solution);
            }

            // Depth-first search
            if (searchType == "df") {
                Tree<T> solution = DepthSearch(root, checkGoal, computeSuccessors);

                if (solution != null) return SolutionSteps(solution);
            }

            // Iterative deepening search
            if (searchType == "id") {
                Tree<T> solution = IterDepthSearch(root, checkGoal, computeSuccessors);

                if (solution != null) return SolutionSteps(solution);
            }

            // Bi-directional search
            if (searchType == "bd") {
                Tree<T> solution = BiDirectionalSearch(root, bdEndState, computeSuccessors);

                if (solution != null) return SolutionSteps(solution);
            }

            // Else, we've exhausted all states with no solution
            return null;
        }

        // Helper function to build the list of states from initial to final
        LinkedList<T> SolutionSteps(Tree<T> solution) {
            LinkedList<T> steps = new LinkedList<T>();

            // We build the solution steps starting from the solution, using the parent to move backwards
            // We prepend each state of the board so at the end, the linked list will be in order from initial state to solution
            steps.Prepend(solution.value);
            while (solution.parent != null) {
                solution = solution.parent;
                steps.Prepend(solution.value);
            }

            return steps;
        }

        // Function for handling depth-first search
        Tree<T> DepthSearch(Tree<T> data, Func<T, bool> checkGoal, Func<T, LinkedList<T>> computeSuccessors) {
            // Create stack, push initial node
            LinkedList<Tree<T>> stack = new LinkedList<Tree<T>>();
            stack.Prepend(data);

            while (!stack.isEmpty()) {
                // Pop first state off stack
                Tree<T> currentState = stack.First.data;
                stack.RemoveFirst();

                // Return state if it is the goal
                if (checkGoal(currentState.value)) return currentState;

                // Otherwise, add to previous state list
                previousStates.Append(currentState.value);

                // Then create successors and push to stack
                currentState.AddChildren(computeSuccessors(currentState.value));

                // Pushing to stack in reverse order so it traverses the "left side" of the tree first
                // Ultimately this doesn't matter, it is simply preference
                LinkedList<Tree<T>>.Node child = currentState.children.Last;
                while (child != null) {
                    if (!previousStates.Contains(child.data.value)) stack.Prepend(child.data);
                    child = child.parent;
                }
                // Thread.Sleep(500); // Line to slow down for the sake of reading debug output
            }
            // If no solution is found, return null
            return null;
        }

        Tree<T> IterDepthSearch(Tree<T> data, Func<T, bool> checkGoal, Func<T, LinkedList<T>> computeSuccessors) {
            int maxDepth = 1;
            // Depth Limit is the limiting depth number, max depth is the current maximum depth the algorithm will be searching (which increments as it finishes)
            int depthLimit = 1000;

            while (maxDepth <= depthLimit) {
                // Create stack, push initial node
                LinkedList<Tree<T>> stack = new LinkedList<Tree<T>>();
                stack.Prepend(data);
                // Reset previous states
                previousStates = new LinkedList<T>();

                while (!stack.isEmpty()) {
                    // Pop first state off stack
                    Tree<T> currentState = stack.First.data;
                    stack.RemoveFirst();

                    // Return state if it is the goal
                    if (checkGoal(currentState.value)) return currentState;

                    // Otherwise, add to previous state list
                    previousStates.Append(currentState.value);

                    // Then create successors and push to stack if we have not reached max depth AND children do not yet exist
                    // The children length being 0 is important to prevent re-generating children/successors that already exist
                    if (currentState.children.Length == 0 && currentState.Depth < depthLimit) {
                        currentState.AddChildren(computeSuccessors(currentState.value));
                    }

                    // Pushing to stack in reverse order so it traverses the "left side" of the tree first
                    // Ultimately this doesn't matter, it is simply preference
                    LinkedList<Tree<T>>.Node child = currentState.children.Last;
                    while (child != null) {
                        if (!previousStates.Contains(child.data.value)) stack.Prepend(child.data);
                        child = child.parent;
                    }
                    // Thread.Sleep(500); // Line to slow down for the sake of reading debug output
                }

                maxDepth++;
            }
            // If no solution is found, return null
            return null;
        }

        Tree<T> BreadthSearch(Tree<T>data, Func<T,bool> checkGoal, Func<T, LinkedList<T>> computeSuccessors) {
            // Create queue, add initial node
            LinkedList<Tree<T>> queue = new LinkedList<Tree<T>>();
            queue.Append(data);

            while (!queue.isEmpty()) {
                // Remove first state in queue
                Tree<T> currentState = queue.First.data;
                queue.RemoveFirst();

                // Return state if it is the goal
                if (checkGoal(currentState.value)) return currentState;

                // Otherwise, add to previous state list
                previousStates.Append(currentState.value);

                // Then create successors and add to queue
                currentState.AddChildren(computeSuccessors(currentState.value));

                // Look through list of children and add them to queue if not duplicate
                LinkedList<Tree<T>>.Node child = currentState.children.First;
                while (child != null) {
                    if (!previousStates.Contains(child.data.value)) queue.Append(child.data);
                    child = child.next;
                }
                // Thread.Sleep(500); // Line to slow down for the sake of reading debug output
            }
            // If no solution is found, return null
            return null;
        }

        Tree<T> BiDirectionalSearch(Tree<T> data, T goal, Func<T, LinkedList<T>> computeSuccessors) {
            // Create queues, add initial nodes
            LinkedList<Tree<T>> queue = new LinkedList<Tree<T>>();
            LinkedList<Tree<T>> goalQueue = new LinkedList<Tree<T>>();
            queue.Append(data);
            goalQueue.Append(new Tree<T>(goal));

            LinkedList<Tree<T>> goalPreviousStates = new LinkedList<Tree<T>>();

            while (!queue.isEmpty() || !goalQueue.isEmpty()) {
                if (!goalQueue.isEmpty()) {
                    // Remove first state in queue
                    Tree<T> currentState = goalQueue.First.data;
                    goalQueue.RemoveFirst();

                    // Otherwise, add to previous state list
                    goalPreviousStates.Append(currentState);

                    // Then create successors and add to queue
                    currentState.AddChildren(computeSuccessors(currentState.value));

                    // Look through list of children and add them to queue if not duplicate
                    LinkedList<Tree<T>>.Node child = currentState.children.First;
                    while (child != null) {
                        if (!GoalContains(goalPreviousStates, child.data.value)) goalQueue.Append(child.data);
                        child = child.next;
                    }
                    // Thread.Sleep(500); // Line to slow down for the sake of reading debug output
                }
                if (!queue.isEmpty()) {
                    // Remove first state in queue
                    Tree<T> currentState = queue.First.data;
                    queue.RemoveFirst();

                    // Return state if it is the goal
                    if (GoalContains(goalPreviousStates, currentState.value)) return StitchGoal(goalPreviousStates, currentState);

                    // Otherwise, add to previous state list
                    previousStates.Append(currentState.value);

                    // Then create successors and add to queue
                    currentState.AddChildren(computeSuccessors(currentState.value));

                    // Look through list of children and add them to queue if not duplicate
                    LinkedList<Tree<T>>.Node child = currentState.children.First;
                    while (child != null) {
                        if (!previousStates.Contains(child.data.value)) queue.Append(child.data);
                        child = child.next;
                    }
                    // Thread.Sleep(500); // Line to slow down for the sake of reading debug output
                }
            }
            // If no solution is found, return null
            return null;
        }

        // Edited function of Contains to ensure we can rebuild the tree
        // and for navigating the previousStates Tree<T> list as opposed to a List<T>
        public bool GoalContains(LinkedList<Tree<T>> list, T data) {
            LinkedList<Tree<T>>.Node node = list.First;
            while (node != null) {
                if (data.Equals(node.data.value)) {
                    return true;
                } else {
                    node = node.next;
                }
            }
            return false;
        }

        // Helper function for "stitching" the path between the goal search and normal search
        public Tree<T> StitchGoal(LinkedList<Tree<T>> goalStates, Tree<T> linkedState) {
            // Make node of current node to iterate through initial list (similar to GoalContains, but more than a boolean)
            // goalLinkedState used to keep note of the overlapped "solution" from bi-directional search
            LinkedList<Tree<T>>.Node node = goalStates.First;
            Tree<T> goalLinkedState = null;
            // Equivalent logic to GoalContains
            while (node != null) {
                if (linkedState.value.Equals(node.data.value)) {
                    goalLinkedState = node.data;
                    break;
                } else {
                    node = node.next;
                }
            }

            // Once we have the overlapping solution, build the tree using the "linkedState"
            // such that linkedState finishes at the goal
            goalLinkedState = goalLinkedState.parent;

            while (goalLinkedState != null) {
                linkedState = linkedState.AddChild(goalLinkedState.value);
                goalLinkedState = goalLinkedState.parent;
            }

            // Finally return the ending goal state's Tree which contains the path of the solution, just like other searches
            return linkedState;
        }
    }

    // Generic Linked List class for holding the successors
    public class LinkedList<T> {
        public Node First { get; private set; }
        public Node Last { get; private set; }
        public int Length { get; private set; }

        public LinkedList() {
            First = null;
            Last = null;
            Length = 0;
        }

        // Append successors, set up node organization as well
        public void Append(T data) {
            Node node = new Node(data);
            // If first is null, then the list is empty, no need to check last
            if (First == null) {
                // Thus the new single node is both first and last
                First = node;
                Last = node;
            } else {
                // Otherwise, set up the pointers as you would normally
                Last.next = node;
                node.parent = Last;
                Last = node;
            }
            Length++;
        }

        public void Append(LinkedList<T> list) {
            Node node = list.First;
            while (node != null) {
                Append(node.data);
                node = node.next;
            }
        }

        public void Prepend(T data) {
            Node node = new Node(data);
            // If first is null then the list is empty
            if (First == null) {
                First = node;
                Last = node;
            } else {
                // Otherwise we add this new node to the front of the list
                node.next = First;
                First.parent = node;
                First = node;
            }
            Length++;
        }

        public void RemoveNode(Node node) {
            // Fix first/last pointers
            if (node == First) First = node.next;
            if (node == Last) Last = node.parent;

            // Ensure that no operations are ran on null
            if (node.parent != null) node.parent.next = node.next;
            if (node.next != null) node.next.parent = node.parent;

            Length--;
        }

        public void RemoveFirst() {
            RemoveNode(First);
        }

        public void RemoveLast() {
            RemoveNode(Last);
        }

        public Node GetNode(int index) {
            if (index < 0 || index >= Length) return null;

            Node node = First;
            for (int i=0; i < index; i++) {
                node = node.next;
            }
            return node;
        }

        // Function to check if the data is already contained, to help avoid duplicate states
        public bool Contains(T data) {
            Node node = First;
            while (node != null) {
                if (data.Equals(node.data)) {
                    return true;
                } else {
                    node = node.next;
                }
            }
            return false;
        }

        // Returns true if the list is empty
        public bool isEmpty() {
            if (First == null) {
                return true;
            }
            return false;
        }

        // Generic node for organizing the list
        public class Node {
            public T data;
            public Node parent;
            public Node next;

            public Node (T newData) {
                data = newData;
                parent = null;
                next = null;
            }
        }
    }

    public class Tree<T> {
        public T value;
        public int Depth { private set; get; }
        public Tree<T> parent;
        public LinkedList<Tree<T>> children;

        public Tree(T data, Tree<T> parent=null) {
            value = data;
            children = new LinkedList<Tree<T>>();
            this.parent = parent;

            if (parent == null) {
                Depth = 0;
            } else {
                Depth = parent.Depth + 1;
            }
        }

        public Tree<T> AddChild(T data) {
            Tree<T> child = new Tree<T>(data, this);
            children.Append(child);
            return child;
        }

        public void AddChildren(LinkedList<T> list) {
            LinkedList<T>.Node node = list.First;

            while(node != null) {
                AddChild(node.data);
                node = node.next;
            }
        }
    }

    public class PuzzleState {
        protected int[] data;
        public int Width { private set; get; }

        public PuzzleState(int[] data, int width) {
            this.data = data;
            Width = width;
        }

        public PuzzleState(PuzzleState copy) {
            Width = copy.Width;
            data = new int[Width * Width];
            Array.Copy(copy.data, data, Width * Width);
        }

        // Indexer to allow us to use square brackets on this type
        public int this[int x, int y] {
            get { return data[x + y * Width]; }
            set { data[x + y * Width] = value; }
        }

        // Swap values of two locations (used for the movement functions)
        public void Swap(int x1, int y1, int x2, int y2) {
            int temp = this[x1, y1];
            this[x1, y1] = this[x2, y2];
            this[x2, y2] = temp;
        }

        // Override Equals function to use our own when compared with another of this object
        public override bool Equals(object obj) {
            if (obj is PuzzleState) return Equals((PuzzleState)obj);
            return base.Equals(obj);
        }

        // Using SequenceEqual to compare arrays, basically makes sure all values in array are in same order
        public bool Equals(PuzzleState state) {
            return data.SequenceEqual(state.data);
        }

        public void Print() {
            string output = string.Join(" ", data.Select(x => x.ToString()).ToArray());
            Console.WriteLine(output);
        }
    }
}